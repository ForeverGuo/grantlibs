import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.BZPRC472.js";const y=JSON.parse('{"title":"最长递增子序列","description":"","frontmatter":{},"headers":[],"relativePath":"leetcode/Longest Increasing Subsequence.md","filePath":"leetcode/Longest Increasing Subsequence.md","lastUpdated":1745204382000}'),l={name:"leetcode/Longest Increasing Subsequence.md"},h=n(`<h1 id="最长递增子序列" tabindex="-1">最长递增子序列 <a class="header-anchor" href="#最长递增子序列" aria-label="Permalink to &quot;最长递增子序列&quot;">​</a></h1><h2 id="题目描述" tabindex="-1">题目描述 <a class="header-anchor" href="#题目描述" aria-label="Permalink to &quot;题目描述&quot;">​</a></h2><div style="color:#E6A23C;font-size:18px;padding:20px 0;"><p>给你一个整数数组 nums，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p></div><h2 id="方法一-动态规划-o-n-2-时间复杂度" tabindex="-1">方法一 ：动态规划(O(n^2) 时间复杂度) <a class="header-anchor" href="#方法一-动态规划-o-n-2-时间复杂度" aria-label="Permalink to &quot;方法一 ：动态规划(O(n^2) 时间复杂度)&quot;">​</a></h2><ol><li>定义状态</li></ol><p>dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度。</p><ol start="2"><li>初始化</li></ol><p>对于数组中的每个元素，以它自身结尾的递增子序列的长度至少为 1。因此，我们将 dp 数组的所有元素初始化为 1。</p><ol start="3"><li>状态转移方程</li></ol><p>对于每个 i (从 1 到 n-1)，我们需要遍历它之前的所有元素 j (从 0 到 i-1)。如果 nums[i] &gt; nums[j]，这意味着我们可以将 nums[i] 添加到以 nums[j] 结尾的递增子序列的后面，形成一个新的更长的递增子序列。因此，我们可以更新 dp[i] 的值为 max(dp[i], dp[j] + 1)。</p><ol start="4"><li>返回结果</li></ol><p>遍历完整个 nums 数组后，dp 数组中最大的值就是最长递增子序列的长度。</p><h2 id="代码实现" tabindex="-1">代码实现 <a class="header-anchor" href="#代码实现" aria-label="Permalink to &quot;代码实现&quot;">​</a></h2><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lengthOfLIS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, nums: List[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nums)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      dp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[j]:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            dp[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dp[i], dp[j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dp) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></div><h2 id="方法二-动态规划-o-nlogn-时间复杂度" tabindex="-1">方法二：动态规划（O(nlogn) 时间复杂度） <a class="header-anchor" href="#方法二-动态规划-o-nlogn-时间复杂度" aria-label="Permalink to &quot;方法二：动态规划（O(nlogn) 时间复杂度）&quot;">​</a></h2><p>这种方法维护一个列表 tails，其中 tails[i] 是长度为 i+1 的所有递增子序列的最小尾部元素。</p><ol><li><p>初始化 tails 是一个空列表。</p></li><li><p>遍历 nums 数组</p></li></ol><p>对于每个 num in nums:</p><ul><li><p>如果 tails 为空或者 num 大于 tails 的最后一个元素，这意味着我们可以将 num 扩展到当前最长的递增子序列的末尾，所以我们将 num 添加到 tails 中。</p></li><li><p>如果 num 小于或等于 tails 中的某个元素，我们希望找到一个长度相同的递增子序列，其尾部元素尽可能小，这样更有利于后续元素的扩展。我们可以使用二分查找在 tails 中找到第一个大于或等于 num 的元素，并用 num 替换它。这样做不会改变当前最长递增子序列的长度，但它使得相同长度的递增子序列的尾部更小。</p></li></ul><ol start="3"><li>结果</li></ol><p>遍历完 nums 数组后，tails 的长度就是最长递增子序列的长度。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bisect</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lengthOfLIS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, nums: List[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      tails </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tails </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tails[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          tails.append(num)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          idx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bisect.bisect_left(tails, num)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          tails[idx] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tails)</span></span></code></pre></div><h2 id="复杂度分析" tabindex="-1">复杂度分析: <a class="header-anchor" href="#复杂度分析" aria-label="Permalink to &quot;复杂度分析:&quot;">​</a></h2><ul><li><p>动态规划</p><ul><li>时间复杂度：两层循环，O(n^2)。</li><li>空间复杂度：需要一个长度为 n 的 dp 数组，O(n)。</li></ul></li><li><p>动态规划 + 二分查找</p><ul><li>时间复杂度：遍历 nums 数组需要 O(n)，每次在 tails 中进行二分查找需要 O(log n)，总的时间复杂度为 O(nlogn)。</li><li>空间复杂度：需要一个 tails 列表，最坏情况下其长度可能为 n，O(n)。</li></ul></li></ul>`,24),t=[h];function p(k,e,r,E,d,g){return a(),i("div",null,t)}const c=s(l,[["render",p]]);export{y as __pageData,c as default};
